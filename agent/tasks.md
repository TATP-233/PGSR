# LiDAR-PGSR 任务清单

## 任务状态说明
- ✅ 已完成
- 🚧 进行中  
- ⏳ 未开始
- ❌ 已暂停
- 🔄 需要重做

---

## 阶段1: 项目设置和环境准备

### 1.1 开发环境搭建
- ⏳ **T1.1.1** 分析PGSR代码依赖，确保环境兼容性
  - 检查requirements.txt
  - 分析CUDA版本需求
  - 验证PyTorch版本兼容性
- ⏳ **T1.1.2** 分析LiDAR-RT代码依赖，识别额外需求
  - 检查OptiX依赖
  - 分析自定义CUDA kernels
  - 确定硬件加速需求
- ⏳ **T1.1.3** 创建统一的开发环境
  - 合并requirements.txt
  - 设置开发环境配置
  - 测试环境可用性

### 1.2 代码结构分析
- ⏳ **T1.2.1** 深入分析PGSR核心模块
  - 理解gaussian_renderer模块
  - 分析scene表示方法
  - 理解训练和推理流程
- ⏳ **T1.2.2** 深入分析LiDAR-RT核心模块
  - 理解光线追踪实现
  - 分析LiDAR数据处理
  - 理解球谐函数建模
- ⏳ **T1.2.3** 设计集成架构
  - 确定模块集成方案
  - 设计接口规范
  - 规划代码重构策略

### 1.3 数据格式理解
- ⏳ **T1.3.1** 理解KITTI-360数据格式
  - 点云文件格式
  - 相机参数格式
  - 时间戳和姿态信息
- ⏳ **T1.3.2** 理解PGSR数据输入格式
  - SfM点云格式
  - 多视图图像格式
  - 相机参数格式
- ⏳ **T1.3.3** 设计数据转换方案
  - LiDAR到深度图转换
  - 坐标系统一
  - 数据预处理管线

---

## 阶段2: 核心功能迁移

### 2.1 LiDAR数据读取模块
- ⏳ **T2.1.1** 创建KITTI-360数据加载器
  - 实现点云文件读取
  - 实现姿态信息读取
  - 实现序列数据管理
- ⏳ **T2.1.2** 集成到PGSR数据管线
  - 修改scene/__init__.py
  - 创建LiDAR场景类
  - 适配训练数据格式
- ⏳ **T2.1.3** 实现数据格式转换
  - 点云到深度图转换
  - Range image生成
  - 多帧数据融合

### 2.2 LiDAR物理属性建模
- ⏳ **T2.2.1** 扩展高斯基元属性
  - 添加intensity参数
  - 添加ray-drop参数
  - 实现球谐系数存储
- ⏳ **T2.2.2** 实现球谐函数评估
  - 移植SH评估代码
  - 实现方向相关计算
  - 测试数值精度
- ⏳ **T2.2.3** 集成到渲染管线
  - 修改渲染器接口
  - 实现LiDAR属性渲染
  - 测试基本功能

### 2.3 深度监督训练
- ⏳ **T2.3.1** 修改损失函数
  - 移除RGB损失项
  - 添加深度损失项
  - 添加intensity损失项
  - 添加ray-drop损失项
- ⏳ **T2.3.2** 实现深度渲染
  - 基于PGSR深度渲染方法
  - 适配LiDAR格式
  - 确保数值稳定性
- ⏳ **T2.3.3** 实现训练循环
  - 修改train.py主循环
  - 实现批处理逻辑
  - 添加进度监控

---

## 阶段3: PGSR几何约束集成

### 3.1 平面化高斯约束
- ⏳ **T3.1.1** 实现高斯平面化损失
  - 移植Ls损失函数
  - 集成到LiDAR训练中
  - 调节损失权重
- ⏳ **T3.1.2** 实现无偏深度渲染
  - 适配LiDAR深度格式
  - 确保平面参数正确
  - 测试深度精度
- ⏳ **T3.1.3** 验证几何一致性
  - 对比平面化前后效果
  - 测试表面重建质量
  - 分析收敛特性

### 3.2 几何正则化损失
- ⏳ **T3.2.1** 实现单视图几何约束
  - 移植局部平面假设
  - 实现边缘感知权重
  - 集成到LiDAR场景
- ⏳ **T3.2.2** 实现多视图几何约束
  - 移植多视图一致性损失
  - 适配LiDAR多帧数据
  - 实现几何遮挡估计
- ⏳ **T3.2.3** 实现多视图光度约束
  - 使用深度信息替代RGB
  - 实现NCC一致性
  - 调节约束权重

### 3.3 损失函数平衡
- ⏳ **T3.3.1** 设计联合损失函数
  - 平衡LiDAR物理损失和几何损失
  - 确定合适的权重策略
  - 实现自适应权重调节
- ⏳ **T3.3.2** 实验损失权重组合
  - 测试不同权重配置
  - 分析收敛行为
  - 选择最优配置
- ⏳ **T3.3.3** 优化训练稳定性
  - 处理数值不稳定问题
  - 实现梯度裁剪
  - 添加异常检测

---

## 阶段4: 系统集成和测试

### 4.1 完整训练管线实现
- ⏳ **T4.1.1** 集成所有模块
  - 确保模块间接口正确
  - 测试端到端训练
  - 修复集成问题
- ⏳ **T4.1.2** 实现训练配置管理
  - 创建统一配置文件
  - 实现参数验证
  - 添加配置文档
- ⏳ **T4.1.3** 实现训练监控
  - 添加损失曲线可视化
  - 实现中间结果保存
  - 添加训练状态检查点

### 4.2 KITTI-360数据集测试
- ⏳ **T4.2.1** 准备测试数据
  - 下载KITTI-360数据集
  - 实现数据预处理
  - 创建训练/验证划分
- ⏳ **T4.2.2** 实现基线对比
  - 实现原始3DGS基线
  - 实现PGSR基线
  - 实现LiDAR-RT基线
- ⏳ **T4.2.3** 运行完整训练测试
  - 静态场景训练测试
  - 收敛性验证
  - 性能指标评估

### 4.3 结果分析和优化
- ⏳ **T4.3.1** 几何精度评估
  - Chamfer距离计算
  - 表面法向量精度
  - 深度图误差分析
- ⏳ **T4.3.2** 物理真实性评估
  - Ray-drop准确性
  - 强度值误差
  - 与真实数据对比
- ⏳ **T4.3.3** 性能优化
  - 训练时间优化
  - 内存使用优化
  - 渲染速度优化

---

## 阶段5: 文档和清理

### 5.1 代码文档完善
- ⏳ **T5.1.1** 添加代码注释
  - 核心算法注释
  - 接口文档
  - 参数说明
- ⏳ **T5.1.2** 创建使用文档
  - 安装指南
  - 数据准备指南
  - 训练配置指南
- ⏳ **T5.1.3** 创建开发文档
  - 架构设计文档
  - 扩展指南
  - 调试指南

### 5.2 测试和验证
- ⏳ **T5.2.1** 单元测试
  - 核心函数测试
  - 数据处理测试
  - 渲染精度测试
- ⏳ **T5.2.2** 集成测试
  - 端到端测试
  - 性能回归测试
  - 边界条件测试
- ⏳ **T5.2.3** 用户测试
  - 易用性测试
  - 文档完整性测试
  - 安装流程测试

### 5.3 项目清理
- ⏳ **T5.3.1** 代码重构
  - 去除调试代码
  - 优化代码结构
  - 统一编码风格
- ⏳ **T5.3.2** 清理临时文件
  - 删除测试文件
  - 清理缓存数据
  - 整理输出结果
- ⏳ **T5.3.3** 最终验证
  - 完整功能测试
  - 性能基准测试
  - 交付质量检查

---

## 测试策略

每个任务完成后都需要进行相应的测试：

### 单元测试
- 创建test_[module].py文件
- 测试完成后删除临时测试文件
- 确保测试覆盖率

### 集成测试  
- 小规模数据集验证
- 功能正确性检查
- 性能基准对比

### 回归测试
- 修改后重新运行关键测试
- 确保没有破坏已有功能
- 验证性能没有显著下降

---

## 风险和缓解策略

### 高风险任务
- **T2.2.3**: LiDAR属性渲染集成 - 可能需要大幅修改渲染器
- **T3.1.2**: 无偏深度渲染适配 - 数值稳定性问题
- **T3.3.1**: 联合损失函数设计 - 权重平衡困难

### 缓解策略
- 保持代码版本控制
- 每个阶段都有回退方案  
- 充分的单元测试
- 渐进式集成策略 