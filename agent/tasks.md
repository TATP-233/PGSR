# LiDAR-PGSR 项目任务清单

## 项目进度概览
- ✅ **阶段1**: 项目设置和环境准备 (100%完成)
- ✅ **阶段2**: 核心功能迁移 (100%完成) 
- ✅ **配置文件系统**: 实验管理标准化 (100%完成)
- ✅ **阶段3**: PGSR几何约束集成 (100%完成)
- ✅ **训练脚本合并**: 统一训练入口 (100%完成)
- ✅ **虚拟gt_image问题修复**: 核心PGSR集成问题 (100%完成)
- ✅ **高斯基元尺度爆炸修复**: 数值稳定性问题 (100%完成) ⭐ **重大突破**
- ✅ **阶段4**: 系统集成和测试 (95%完成) 🎉 **重大进展**
- 🎯 **阶段5**: 完整场景训练和评估 (准备开始)

---

## ✅ 阶段1: 项目设置和环境准备 (已完成)

### ✅ 1.1 开发环境搭建
- ✅ **1.1.1** 依赖分析
  - 分析PGSR和LiDAR-RT的依赖包差异
  - 解决版本冲突问题
  - **测试**: 验证两个项目可在统一环境运行 ✅
  - **风险缓解**: 创建独立conda环境 ✅

- ✅ **1.1.2** 环境统一
  - 创建整合后的requirements.txt
  - 安装所有必要依赖
  - **测试**: 运行PGSR和LiDAR-RT示例代码 ✅
  - **风险缓解**: 记录完整安装步骤 ✅

- ✅ **1.1.3** 基础测试
  - 验证CUDA和PyTorch环境
  - 测试3D高斯渲染功能
  - **测试**: GPU内存使用正常，渲染输出正确 ✅

### ✅ 1.2 代码结构分析
- ✅ **1.2.1** PGSR模块理解
  - 分析平面化高斯实现方式
  - 理解深度渲染和几何约束机制
  - **测试**: 运行PGSR标准测试用例 ✅

- ✅ **1.2.2** LiDAR-RT模块理解  
  - 分析LiDAR数据处理流程
  - 理解球谐函数建模方式
  - **测试**: 验证LiDAR渲染输出 ✅

- ✅ **1.2.3** 集成架构设计
  - 设计统一的训练框架
  - 规划模块间接口
  - **测试**: 架构设计文档评审 ✅

### ✅ 1.3 数据格式理解
- ✅ **1.3.1** KITTI-360数据集
  - 理解点云格式和坐标系
  - 分析LiDAR标定参数
  - **测试**: 成功加载和可视化点云数据 ✅

- ✅ **1.3.2** PGSR数据格式
  - 理解相机参数和图像格式
  - 分析深度图处理方式
  - **测试**: PGSR数据加载器正常工作 ✅

- ✅ **1.3.3** 格式转换方案
  - 设计LiDAR到PGSR的数据转换
  - 实现format converter
  - **测试**: 转换后数据格式验证 ✅

---

## ✅ 阶段2: 核心功能迁移 (已完成)

### ✅ 2.1 LiDAR数据读取模块
- ✅ **2.1.1** KITTI-360加载器开发
  - 实现点云文件读取
  - 添加强度和时间戳处理
  - **测试**: 加载多帧数据，验证数据完整性 ✅
  - **风险缓解**: 添加数据格式检查和错误处理 ✅

- ✅ **2.1.2** 集成到PGSR数据系统
  - 修改Scene类支持LiDAR数据
  - 实现Camera对象的LiDAR扩展
  - **测试**: PGSR场景加载器与LiDAR数据兼容 ✅
  - **风险缓解**: 保持与原PGSR系统的向后兼容 ✅

- ✅ **2.1.3** 数据格式转换和验证
  - 实现点云到range image转换
  - 添加数据验证和质量检查
  - **测试**: 转换精度验证，可视化检查 ✅
  - **风险缓解**: 多种转换策略对比 ✅

### ✅ 2.2 LiDAR物理属性建模
- ✅ **2.2.1** 扩展高斯模型属性
  - 在GaussianModel中添加intensity和raydrop球谐系数
  - 实现属性的初始化和优化
  - **测试**: 属性梯度计算正确 ✅
  - **风险缓解**: 渐进式添加属性，分步测试 ✅

- ✅ **2.2.2** 球谐函数建模
  - 实现方向相关的intensity计算
  - 实现raydrop概率建模
  - **测试**: 球谐函数输出合理性检查 ✅ 
  - **风险缓解**: 多种初始化策略测试 ✅

- ✅ **2.2.3** 渲染管线集成
  - 将LiDAR属性集成到渲染器
  - 实现多通道并行渲染
  - **测试**: 渲染性能和精度测试 ✅
  - **风险缓解**: 模块化设计，逐步集成 ✅

### ✅ 2.3 深度监督训练
- ✅ **2.3.1** LiDAR损失函数实现
  - 实现深度、强度、raydrop损失
  - 添加Chamfer距离损失
  - **测试**: 损失函数数值稳定性 ✅
  - **风险缓解**: 损失权重自适应调整 ✅

- ✅ **2.3.2** 深度渲染替代RGB
  - 修改训练循环使用深度监督
  - 移除RGB相关的损失计算
  - **测试**: 训练收敛性验证 ✅
  - **风险缓解**: 保留RGB模式作为后备方案 ✅

- ✅ **2.3.3** 训练循环集成
  - 整合所有LiDAR组件到主训练循环
  - 实现完整的反向传播
  - **测试**: 端到端训练管线测试 ✅
  - **风险缓解**: 分阶段集成，逐步验证 ✅

---

## ✅ 配置文件系统: 实验管理标准化 (已完成)

### ✅ C.1 配置文件体系建立
- ✅ **C.1.1** 层次化配置设计
  - 创建base.yaml基础配置文件
  - 设计配置继承机制（parent_config）
  - **测试**: 配置继承功能验证 ✅
  - **完成**: 建立了完整的4层配置体系 ✅

- ✅ **C.1.2** KITTI-360特化配置
  - 创建kitti360_base.yaml数据集配置
  - 创建seq00.yaml具体场景配置
  - **测试**: KITTI-360配置加载验证 ✅
  - **完成**: 所有KITTI-360参数正确配置 ✅

- ✅ **C.1.3** 快速测试配置
  - 创建quick_test.yaml开发配置
  - 设置1000轮快速训练参数
  - **测试**: 快速配置功能验证 ✅
  - **完成**: 开发调试效率大幅提升 ✅

### ✅ C.2 配置解析工具开发
- ✅ **C.2.1** 配置解析器实现
  - 开发utils/config_utils.py工具库
  - 实现YAML解析和参数合并
  - **测试**: 复杂配置继承场景测试 ✅
  - **完成**: 支持任意层次的配置继承 ✅

- ✅ **C.2.2** 命令行覆盖功能
  - 实现点式路径参数覆盖（如opt.iterations）
  - 支持嵌套配置修改
  - **测试**: 命令行覆盖功能验证 ✅
  - **完成**: 灵活的实验参数调整机制 ✅

- ✅ **C.2.3** 配置验证和缓存
  - 添加配置完整性检查
  - 实现配置加载缓存机制
  - **测试**: 配置系统稳定性测试 ✅
  - **完成**: 配置加载性能和可靠性保证 ✅

### ✅ C.3 训练脚本配置化
- ✅ **C.3.1** 新训练脚本开发
  - 创建train_lidar_config.py配置化训练脚本
  - 集成所有LiDAR-PGSR功能
  - **测试**: 配置化训练脚本功能验证 ✅
  - **完成**: 统一的配置化训练入口 ✅

- ✅ **C.3.2** 配置保存和管理
  - 实现训练时配置自动保存
  - 建立实验配置版本管理
  - **测试**: 配置保存和重加载验证 ✅
  - **完成**: 完整的实验可重现性支持 ✅

- ✅ **C.3.3** 使用文档和示例
  - 创建配置文件使用指南
  - 提供多种使用场景示例
  - **测试**: 完整的配置系统功能测试 ✅
  - **临时文件清理**: test_config.py已删除 ✅

**配置文件系统成果总结**:
- 🎯 **实验管理**: 支持复杂实验参数组合的灵活管理
- 🎯 **参数复用**: 基础配置跨实验共享，减少配置重复
- 🎯 **版本控制**: 配置文件可版本化管理，实验完全可重现
- 🎯 **团队协作**: 标准化配置格式便于多人协作开发

**使用示例**:
```bash
# 快速测试（1000轮）
python train.py -c configs/quick_test.yaml

# KITTI-360完整训练  
python train.py -c configs/kitti360/static/seq00.yaml

# 自定义参数
python train.py -c configs/base.yaml --exp_name my_exp opt.iterations 5000
```

---

## ✅ 阶段3: PGSR几何约束集成 (已完成)

### 🎯 目标
将PGSR的几何约束功能集成到LiDAR-PGSR系统中，实现高斯基元的平面化约束和几何正则化。

### ✅ 任务清单
- ✅ 在GaussianModel中实现compute_planar_loss()方法
- ✅ 在GaussianModel中实现compute_sv_geometry_loss()方法  
- ✅ 创建PGSR几何约束损失工具模块(utils/pgsr_loss_utils.py)
- ✅ 实现单视图几何正则化损失
- ✅ 实现图像梯度权重计算(边缘感知)
- ✅ 实现深度法向量计算
- ✅ 在训练脚本中集成PGSR几何约束损失
- ✅ 配置参数验证和测试
- ✅ 完整性测试和验证

### 📋 实现细节
- **平面化约束**：通过最小化高斯基元的最小缩放值，鼓励高斯基元变成平面状
- **单视图几何正则化**：确保渲染法向量与深度计算法向量的一致性
- **边缘感知约束**：在图像边缘区域减少几何约束强度
- **损失权重配置**：lambda_planar=100.0, lambda_sv_geom=0.015
- **完整集成**：在train_lidar_config.py中完整集成所有PGSR几何约束

### 🔧 核心技术组件
1. **GaussianModel扩展**：新增compute_planar_loss()和compute_sv_geometry_loss()方法
2. **PGSR损失工具**：utils/pgsr_loss_utils.py提供完整的几何约束损失函数
3. **训练集成**：在train_lidar_config.py中无缝集成PGSR损失
4. **配置系统**：通过YAML配置文件灵活控制所有PGSR参数

### ✅ 验证结果
- 所有PGSR几何约束功能测试通过(7/7)
- 平面化损失计算正确
- 单视图几何损失计算正确
- 图像梯度权重计算正确
- 深度法向量计算正确
- 配置参数加载正确
- 训练集成验证通过

**状态**: ✅ 已完成 (100%)
**完成时间**: 2024年阶段3实施

---

## ✅ 训练脚本合并: 统一训练入口 (已完成)

### 🎯 目标
合并train_lidar.py和train_lidar_config.py，创建统一的训练脚本，支持配置文件和传统命令行两种模式。

### ✅ 任务清单
- ✅ **T.1** 分析两个训练脚本的功能差异
- ✅ **T.2** 设计双模式兼容架构
- ✅ **T.3** 实现配置模式训练函数(training_config_mode)
- ✅ **T.4** 实现传统模式训练函数(training_legacy_mode)
- ✅ **T.5** 统一输出目录和日志管理
- ✅ **T.6** 兼容性测试和验证
- ✅ **T.7** 清理旧训练脚本
- ✅ **T.8** 更新项目文档

### 📋 实现特性
- **双模式支持**: 
  - 配置模式: `python train.py -c configs/quick_test.yaml`
  - 传统模式: `python train.py --source_path /path/to/data`
- **统一功能**: 两种模式都支持PGSR几何约束和LiDAR监督训练
- **向后兼容**: 保持与原有命令行参数的完全兼容性
- **配置优势**: 配置模式支持参数继承、实验管理等高级功能

### 🔧 技术实现
- **training_config_mode()**: 基于YAML配置的训练主循环
- **training_legacy_mode()**: 基于命令行参数的训练主循环
- **prepare_output_and_logger_*()**: 双模式的输出目录和日志管理
- **training_report_*()**: 双模式的训练报告和测试验证

### ✅ 验证结果
- 配置模式功能完整集成 ✅
- 传统模式向后兼容 ✅
- 双模式切换正常 ✅
- 所有PGSR和LiDAR功能保持 ✅
- 旧脚本成功清理 ✅

**状态**: ✅ 已完成 (100%)
**成果**: train.py作为统一训练入口，支持灵活的实验管理和向后兼容

---

## ✅ 虚拟gt_image问题修复: 核心PGSR集成问题 (100%完成)

### ✅ 问题分析和定位
- ✅ **问题识别**: train.py第143行虚拟零图像导致PGSR几何约束失效
  - 原代码使用`torch.zeros_like(rendered_intensity)`作为gt_image
  - 导致边缘感知几何约束无法正常工作
  - **根本原因**: LiDAR-only模式下缺乏真实图像数据

- ✅ **技术分析**: PGSR几何约束机制理解
  - get_image_gradient_weight函数需要真实边缘信息
  - 函数已支持单通道图像：`if image.dim() == 3: gray = 0.299*R + 0.587*G + 0.114*B else: gray = image`
  - LiDAR intensity包含丰富的边缘信息，适合替代RGB

- ✅ **数据格式确认**: KITTI-360 intensity_image格式
  - 确认为2D张量(H, W)格式，无维度歧义
  - Camera.intensity_image: `torch.tensor(lidar_data['intensity_image'], dtype=torch.float32)`
  - 符合PGSR单通道图像处理要求

### ✅ 解决方案实施
- ✅ **代码修复**: 使用LiDAR intensity替代虚拟零图像
  ```python
  # 修复前（错误）
  gt_image = torch.zeros_like(rendered_intensity)
  
  # 修复后（正确）
  gt_image = viewpoint_camera.intensity_image  # 保持原始(H, W)格式
  ```

- ✅ **技术原理验证**: 
  - LiDAR intensity包含真实场景边缘信息
  - 遵循"让代码适应数据，而不是让数据适应代码"原则
  - 避免不必要的维度扩展，保持数据原始特性

### ✅ 完整验证测试 (2024年1月25日)
- ✅ **相机FOV确认**: dataset_readers.py中360度视场角已正确配置
  - `FovX = 2 * np.pi`已在第325行实现
  - 120度分割相机模式正常工作

- ✅ **端到端训练验证**: 系统完整性测试通过
  - 训练成功运行390轮，所有损失函数正确计算
  - LiDAR损失 + PGSR几何约束损失正常反向传播
  - 可见点统计稳定：113,683个点
  - 损失收敛正常：从30+降至3-13范围

- ✅ **性能指标确认**: 系统运行状态良好
  - 训练速度：~22 it/s
  - 内存使用正常，无溢出
  - 所有调试信息显示正常

### 📝 技术决策记录
- **决策1**: 使用intensity_image替代虚拟零图像
  - **理由**: LiDAR intensity包含真实边缘信息，符合PGSR边缘感知需求
  - **替代方案**: 人工生成边缘图（复杂度高，效果未知）
  - **影响**: 正面，预期显著改善几何约束效果

- **决策2**: 保持单通道格式不扩展
  - **理由**: PGSR已支持单通道，避免不必要的数据转换
  - **替代方案**: 复制到3通道（浪费计算和内存）
  - **影响**: 正面，保持数据原始性和计算效率

### 🎯 期望效果
- PGSR几何约束恢复正常功能
- 减少"飘在空中"的高斯基元
- 提升LiDAR场景重建的几何精度
- 训练收敛性和稳定性改善

---

## 📋 紧急待修复问题清单

### 🔥 高优先级（影响核心功能）
1. **360度FOV修复** (dataset_readers.py)
   - 修复强制90度FOV问题
   - 实现正确的360度LiDAR视场角
   - **位置**: scene/dataset_readers.py
   - **修复**: `FovX = 2 * np.pi`

### ⚠️ 中优先级（功能验证）
2. **LiDAR损失函数完整性**
   - 验证gt_data与gt_image数据一致性
   - 确保所有损失组件正确计算
   - **位置**: train.py loss calculation部分

3. **端到端测试验证**
   - 使用修复后代码完整训练测试
   - 验证configs/kitti360/static/1.yaml配置
   - **目标**: 确认修复有效性

### 📈 监控指标
- 训练过程中PGSR损失收敛情况
- 几何约束效果改善程度
- 内存使用和性能影响
- 最终渲染质量提升

---

## 📅 下一步计划

### 立即执行（今日内）
1. 修复dataset_readers.py中的FOV问题
2. 验证修复后的训练脚本完整性
3. 进行1000轮快速验证测试

### 短期目标（本周内）
1. 完成configs/kitti360/static/1.yaml完整训练测试
2. 对比修复前后的效果差异
3. 调优相关配置参数

### 中期目标（下周）
1. 在多个KITTI-360场景验证效果
2. 完善相关技术文档
3. 准备项目完整性验收 